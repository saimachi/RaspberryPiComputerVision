Let's get started with OpenCV! First, however, you're probably going to need to install it. Consider using the pip installer to do so. Information about this approach can be found here: https://www.pyimagesearch.com/2018/09/19/pip-install-opencv/. The article also gives a good description about the major OpenCV packages you can install.

For the more adventurous who want to squeeze out every last bit of performance, OpenCV can be built from source. This method involves CMake, and for Linux users, can be viewed here: https://docs.opencv.org/4.1.1/d7/d9f/tutorial_linux_install.html. macOS users can look here: https://www.pyimagesearch.com/2018/08/17/install-opencv-4-on-macos/. Use the most updated version of the OpenCV source; as of 8/5/2019, it is https://github.com/opencv/opencv/tree/4.1.1. I am intentionally not including Windows instructions here: I do not recommend it as a computer vision development platform. If you must however, there are a plethora of tutorials on the web. 

As this course focuses on the Raspberry Pi, there are ways of building OpenCV natively on the Pi. Since building it is a slow experience, even on my Pi 4 with 2 GB of RAM, I would recommend that you use a Debian docker container to cross-compile. 

I am not an expert on computer vision myself: I am writing this series to ensure that I fully comprehend the core concepts. As such, if something seems inaccurate, file an issue. Let's keep the information on this page as accurate and modern as possible!

NOTE: You can skip to the next tutorial if you're not using a headless setup. 

Many of you may be developing on a headless environment--one which you cannot interact with through a directly connected keyboard and mouse. I am using this approach, as my Raspberry Pi 4 is located in another room. However, this is perfectly fine for computer vision development! With this approach, you will use your local machine (the computer you are presumably using to view this page) to develop code, but execute the developed software on the remote machine (possibly a Raspberry Pi or VPS instance). 

On UNIX and UNIX-like remote systems, SSH can be used to run commands. An SSH system consists of an SSH server running on the remote machine and an SSH client running on the local machine. If you are not using private keys, an SSH system requires the IP address and user credentials of the remote machine. To configure an SSH server on a Debian or Ubuntu remote machine (including the Raspberry Pi), install openssh-server. Use "ssh <user>@<IP address>" to SSH into a remote machine on a Linux or macOS local machine (granted that Remote Login is enabled on macOS and key authentication isn't being used). Windows users should use the PuTTY client. 

Some machines, most notably VPS instances, will require a private key to authenticate. Instructions for setting up this method of authentication can be found here: https://www.digitalocean.com/community/tutorials/how-to-configure-ssh-key-based-authentication-on-a-linux-server. The process is slightly more complicated on Windows, but can be done using PuTTY's utilities. 

SSH is a great way to interact with a machine. However, most developers are more acquainted with the friendliness and productivity of their favorite IDEs. PyCharm is the benchmark IDE for Python development. However, it is not accessible to all developers. Thankfully, there are plenty of free text editors with remote development extensions! Visual Studio Code, in particular, can use the SFTP extension to enable remote development. Information about using this extension with VS Code can be found here: https://marketplace.visualstudio.com/items?itemName=liximomo.sftp. The "Simple" profile should work; use the "privateKeyPath" JSON key for remote systems with key-based authentication.

This sounds great, but how do you view remote GUI applications? Meet X11 forwarding. An X-Window manager is a prerequisite; most Linux distros (including Debian and Ubuntu) already have this. Windows and macOS users should consider Xming and xQuartz, respectively. For macOS and Linux systems, to enable X11 forwarding, simply use "ssh -X <user>@<IP address>". For Windows users, instructions on using Xming and PuTTY can be found here: https://ahmermansoor.blogspot.com/2019/01/configure-x11-forwarding-putty-xming-windows.html. A simple process, either way. Note that X11 forwarding is best used on capable networks where the UI doesn't change much: in other words, don't expect good performance when streaming video remotely.
  
To move files remotely, use SCP. On my local Windows box, I use WinSCP; however, alternatives like FileZilla will work OS-independent. On Unix/Unix clones, the "scp" command can be used manually: to move a file called <file> to directory <dir> of user <user> at machine <IP/hostname>, issue "scp <file> <user>@<IP/hostname>:<dir>". You can also use this command to move files from the remote machine to the local machine. 
  
Some of you acquainted with remote development might be wondering why I didn't mention VNC. We will not be working with live video yet, or video data for that matter, and so when the need arises, I will show you how to configure and seamlessly use VNC then. Prepare your environment for the next tutorial, with actual code!
